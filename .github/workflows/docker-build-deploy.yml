name: Build and Deploy Docker Image

on:
  push:
    branches:
      - main
    paths:
      - 'Dockerfile'
      - 'VERSION'
      - '.github/workflows/docker-build-deploy.yml'
  workflow_dispatch:
    branches:
      - main

env:
  REGISTRY: docker.io
  IMAGE_NAME: phygrid/cuda-pytorch

jobs:
  version-management:
    runs-on: github1
    outputs:
      version: ${{ steps.determine-version.outputs.version }}
      should-build: ${{ steps.check-existing.outputs.should-build }}
      version-changed: ${{ steps.determine-version.outputs.version-changed }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version and auto-increment if needed
        id: determine-version
        run: |
          CURRENT_VERSION=$(cat VERSION)
          echo "Current VERSION file: $CURRENT_VERSION"
          
          # Get the last commit that changed VERSION file
          LAST_VERSION_COMMIT=$(git log -1 --format="%H" -- VERSION 2>/dev/null || echo "")
          CURRENT_COMMIT="${{ github.sha }}"
          
          # Check if VERSION file was manually changed in this push
          VERSION_CHANGED_BY_USER=false
          if [[ -n "$LAST_VERSION_COMMIT" && "$LAST_VERSION_COMMIT" == "$CURRENT_COMMIT" ]]; then
            # VERSION file was changed in this commit, check if it was manual
            if git show --name-only "$CURRENT_COMMIT" | grep -q "VERSION"; then
              VERSION_CHANGED_BY_USER=true
              echo "VERSION file was manually changed in this commit"
            fi
          fi
          
          if [[ "$VERSION_CHANGED_BY_USER" == "true" ]]; then
            # User manually changed VERSION file, use it as-is
            VERSION="v$CURRENT_VERSION"
            echo "Using manually set version: $VERSION"
            echo "version-changed=manual" >> $GITHUB_OUTPUT
          else
            # Auto-increment patch version if tag already exists
            VERSION="v$CURRENT_VERSION"
            if git tag -l | grep -q "^$VERSION$"; then
              echo "Tag $VERSION already exists, auto-incrementing patch version"
              IFS='.' read -ra PARTS <<< "$CURRENT_VERSION"
              MAJOR=${PARTS[0]}
              MINOR=${PARTS[1]}
              PATCH=${PARTS[2]}
              NEW_PATCH=$((PATCH + 1))
              NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
              VERSION="v$NEW_VERSION"
              
              # Update VERSION file
              echo "$NEW_VERSION" > VERSION
              echo "Auto-incremented to: $VERSION"
              echo "version-changed=auto" >> $GITHUB_OUTPUT
            else
              echo "Tag $VERSION does not exist, using current version"
              echo "version-changed=none" >> $GITHUB_OUTPUT
            fi
          fi
          
          # Validate version format
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
            echo "Error: Invalid version format. Expected format: v1.0.0, got: $VERSION"
            exit 1
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Final version: $VERSION"

      - name: Check if Docker image already exists
        id: check-existing
        run: |
          VERSION="${{ steps.determine-version.outputs.version }}"
          
          # Check if image exists on Docker Hub
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$VERSION > /dev/null 2>&1; then
            echo "Error: Docker image ${{ env.IMAGE_NAME }}:$VERSION already exists on Docker Hub"
            echo "should-build=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "Image ${{ env.IMAGE_NAME }}:$VERSION does not exist, proceeding with build"
            echo "should-build=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit auto-incremented version and create tag
        if: steps.determine-version.outputs.version-changed == 'auto' || steps.determine-version.outputs.version-changed == 'manual'
        run: |
          VERSION="${{ steps.determine-version.outputs.version }}"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Configure git to use HTTPS with token
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          
          # Commit VERSION file changes if auto-incremented
          if [[ "${{ steps.determine-version.outputs.version-changed }}" == "auto" ]]; then
            git add VERSION
            git commit -m "Auto-increment version to ${VERSION#v} [skip ci]"
            git push origin main
          fi
          
          # Create and push tag
          if ! git tag -l | grep -q "^$VERSION$"; then
            git tag -a "$VERSION" -m "Release $VERSION"
            git push origin "$VERSION"
            echo "Created and pushed tag: $VERSION"
          else
            echo "Tag $VERSION already exists"
          fi

  build-and-deploy:
    needs: version-management
    if: needs.version-management.outputs.should-build == 'true'
    runs-on: github1
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=tag
            type=raw,value=latest
            type=raw,value=${{ needs.version-management.outputs.version }}
          labels: |
            org.opencontainers.image.title=Phygrid CUDA PyTorch
            org.opencontainers.image.description=PyTorch base image for deep learning inference with GPU support
            org.opencontainers.image.vendor=Phygrid
            org.opencontainers.image.version=${{ needs.version-management.outputs.version }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true
          sbom: true
          build-args: |
            VERSION=${{ needs.version-management.outputs.version }}

      - name: Update image labels in Dockerfile
        run: |
          VERSION="${{ needs.version-management.outputs.version }}"
          sed -i "s/LABEL version=.*/LABEL version=\"$VERSION\"/" Dockerfile
          
          if git diff --quiet; then
            echo "No changes to commit"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            # Configure git to use HTTPS with token
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
            
            git add Dockerfile
            git commit -m "Update version label to $VERSION [skip ci]"
            git push origin main
          fi

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.version-management.outputs.version }}
          release_name: Release ${{ needs.version-management.outputs.version }}
          body: |
            ## Docker Images
            
            - `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}`
            - `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest`
            
            ## Changes
            
            Built from commit: ${{ github.sha }}
            
            ## Architecture Support
            
            - linux/amd64
            - linux/arm64
            
            ## PyTorch Features
            
            - PyTorch 2.8.0 with CUDA 12.8 support
            - Transformers ecosystem with Hugging Face integration
            - Model optimization with bitsandbytes and optimum
            - Computer vision and audio processing libraries
            - RTX 5090 optimizations
          draft: false
          prerelease: false

  notify-success:
    needs: [version-management, build-and-deploy]
    if: success()
    runs-on: github1
    steps:
      - name: Notify Success
        run: |
          echo "‚úÖ Successfully built and deployed ${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}"
          echo "üê≥ Docker Hub: https://hub.docker.com/r/${{ env.IMAGE_NAME }}"
          echo "üì¶ Available tags:"
          echo "  - ${{ needs.version-management.outputs.version }}"
          echo "  - latest"
          echo "üìÑ Version management: ${{ needs.version-management.outputs.version-changed }}"

  notify-failure:
    needs: [version-management, build-and-deploy]
    if: failure()
    runs-on: github1
    steps:
      - name: Notify Failure
        run: |
          echo "‚ùå Failed to build and deploy ${{ env.IMAGE_NAME }}"
          echo "Please check the workflow logs for details."